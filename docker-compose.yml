version: '0.1'
services:
  server:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    container_name: "cassandra-server"
    hostname: "cassandra-server"
    #Mapping ports
    ports:
      # <port_on_local>:<port_in_machine>
      - 8080:8080
    #Will be accessible through os.Getenv("PORT")
    environment:
      - PORT=8080
      # NoSQL: environment variable holding connection URI for Cassandra database
      - CASS_DB=cassandra-a:9042
    # NoSQL: Extremely important! Cassandra takes a lot of time to start!
    # If we don't wait for it to fully initialize we will get exceptions and will not be able to connect!
    depends_on:
      cassandra:
        condition: service_healthy

  # NoSQL: CassandraDB
  cassandra:
    container_name: "cassandra-a"
    image: cassandra
    restart: always
    ports:
      - "9042:9042"
    # Docker healtcheck - checks if database is "alive"
    healthcheck:
      test: [ "CMD-SHELL", "cqlsh -e 'describe cluster'" ]
      interval: 15s
      timeout: 5s
      retries: 15
    volumes:
      - cass_store:/var/lib/cassandra/data
  rest-service:
    container_name: rest_service
    build: ./
    restart: always
    ports:
      - "9090:9090"
  profile-service:
    container_name: profile-service
    build: ../profile-service
    restart: always
    ports:
      - "9091:9091"
    environment:
      - PORT=8080
      # NoSQL: environment variable holding connection URI for Mongo database
      # protocol://username:password@hostname:port
      - MONGO_DB_URI=mongodb://root:pass@mongo-profile:27017
      # - MONGO_DB_URI=mongodb://mongo:27017
      # NoSQL: Our service will try to connect to Mongo before it is up
      # in order to avoid that problem, we specify that it depends on mongo service
      # which defines the order of starting the containers
      # Additionaly we specify that mongo service needs to pass a healthcheck
    depends_on:
      mongo-profile:
          condition: service_healthy
  mongo-profile:
    container_name: mongo-profile
    image: mongo
    restart: always
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: pass
      MONGO_INITDB_DATABASE: mongoProfile
    # Docker healtcheck - checks if database is "alive"
    healthcheck:
      test: echo 'db.runCommand("ping").ok'
      interval: 10s
      timeout: 10s
      retries: 10
    volumes:
      - mongo_profiles:/data/db

  accommodation-service:
    container_name: accommodation-service
    build: ../accommodation-service
    restart: always
    ports:
      - "9093:9093"
    environment:
      - PORT=8080
      # NoSQL: environment variable holding connection URI for Mongo database
      # protocol://username:password@hostname:port

      - CASS_DB=cassandra-a:9042
      # - MONGO_DB_URI=mongodb://mongo:27018
      # NoSQL: Our service will try to connect to Mongo before it is up
      # in order to avoid that problem, we specify that it depends on mongo service
      # which defines the order of starting the containers
      # Additionaly we specify that mongo service needs to pass a healthcheck
    depends_on:

      mongo-accommodation:
          condition: service_healthy
      cassandra:
        condition: service_healthy
  mongo-accommodation:
    container_name: mongo-accommodation
    image: mongo
    restart: always
    ports:
      - "27018:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: pass
      MONGO_INITDB_DATABASE: mongoAccommodation
    # Docker healtcheck - checks if database is "alive"
    healthcheck:
      test: echo 'db.runCommand("ping").ok'
      interval: 10s
      timeout: 10s
      retries: 10
    volumes:
      - mongo_accommodations:/data/db
  reservation-service:
    container_name: reservation-service
    build: ../reservation-service
    restart: always
    ports:
      - "9096:9096"
    environment:
      - PORT=8080
      # NoSQL: environment variable holding connection URI for Mongo database
      # protocol://username:password@hostname:port

      - CASS_DB=cassandra-a:9042
      # - MONGO_DB_URI=mongodb://mongo:27018
      # NoSQL: Our service will try to connect to Mongo before it is up
      # in order to avoid that problem, we specify that it depends on mongo service
      # which defines the order of starting the containers
      # Additionaly we specify that mongo service needs to pass a healthcheck
    depends_on:

      mongo-accommodation:
        condition: service_healthy
      cassandra:
        condition: service_healthy
  mongo-reservation:
    container_name: mongo-reservation
    image: mongo
    restart: always
    ports:
      - "27011:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: pass
      MONGO_INITDB_DATABASE: mongoReservation
    # Docker healtcheck - checks if database is "alive"
    healthcheck:
      test: echo 'db.runCommand("ping").ok'
      interval: 10s
      timeout: 10s
      retries: 10
    volumes:
      - mongo_reservations:/data/db

  auth-service:
    container_name: auth-service
    build: ../Auth-Service
    restart: always
    ports:
      - "9094:9094"
    environment:
      - PORT=8080
      # NoSQL: environment variable holding connection URI for Mongo database
      # protocol://username:password@hostname:port
      - MONGO_DB_URI=mongodb://root:pass@mongo-auth:27017
      # - MONGO_DB_URI=mongodb://mongo:27018
      # NoSQL: Our service will try to connect to Mongo before it is up
      # in order to avoid that problem, we specify that it depends on mongo service
      # which defines the order of starting the containers
      # Additionaly we specify that mongo service needs to pass a healthcheck
    depends_on:
      mongo-accommodation:
          condition: service_healthy
  mongo-auth:
    container_name: mongo-auth
    image: mongo
    restart: always
    ports:
      - "27019:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: pass
      MONGO_INITDB_DATABASE: mongoAuth
    # Docker healtcheck - checks if database is "alive"
    healthcheck:
      test: echo 'db.runCommand("ping").ok'
      interval: 10s
      timeout: 10s
      retries: 10
    volumes:
      - mongo_auths:/data/db
  avaibility-service:
    container_name: avaibility-service
    build: ../Aviability-Service
    restart: always
    ports:
      - "9095:9095"
    environment:
      # NoSQL: environment variable holding connection URI for Mongo database
      # protocol://username:password@hostname:port
      - MONGO_DB_URI=mongodb://root:pass@avaibility-mongo:27017
      # - MONGO_DB_URI=mongodb://mongo:27018
      # NoSQL: Our service will try to connect to Mongo before it is up
      # in order to avoid that problem, we specify that it depends on mongo service
      # which defines the order of starting the containers
      # Additionaly we specify that mongo service needs to pass a healthcheck
    depends_on:
      mongo-accommodation:
        condition: service_healthy
  avaibility-mongo:
    container_name: avaibility-mongo
    image: mongo
    restart: always
    ports:
      - "27015:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: pass
      MONGO_INITDB_DATABASE: mongoAviability
    # Docker healtcheck - checks if database is "alive"
    healthcheck:
      test: echo 'db.runCommand("ping").ok'
      interval: 10s
      timeout: 10s
      retries: 10
    volumes:
      - mongo_ava:/data/db
volumes:
  mongo_profiles:
  mongo_accommodations:
  mongo_auths:
  mongo_ava:
  mongo_reservations:
  cass_store: